/*
********************************************************************
(c) MSU Video Group, http://compression.ru/video/
This source code is property of MSU Graphics and Media Lab

This code may be distributed under LGPL
(see http://www.gnu.org/licenses/lgpl.html for more details).

E-mail: video-measure@compression.ru
Author: Oleg Petrov
********************************************************************
*/

/**
*  \file ICustomPlugin.h
*  \brief More convenient interface for metric development.
*/

#pragma once

#include <vector>
#include <string>

#include <IMetricPlugin.h>
#include <IMetricImage.h>

struct IDinfo {
	IDinfo() {}
	IDinfo(int id, const std::wstring& name) : id(id), name(name) {}

public:
	int id = -1;
	std::wstring name;
};

/*!\brief Convenient interface for metric development
*
*	General interface for metric is IMetricPlugin,
*	but this interface (ICustomPlugin) is much more convenient.
*	ICustomPlugin is adapted to IMetricPlugin through CPluginAdapter.
*	So to create metric, you need to do:
*
*		1. Create CMyMetric that extends ICustomPlugin
*		2. Create the following global exported functions for your dll:
*
*                   VQMT_EXPORT void CreateMetric ( IMetricPlugin** metric )
*                   {
*                   	*metric = new CPluginAdapter ( std::make_unique<CMyMetric>() );
*                   }
*                   
*                   VQMT_EXPORT void ReleaseMetric ( IMetricPlugin* metric )
*                   {
*                   	delete metric;
*                   }
*                   
*                   VQMT_EXPORT int GetVQMTVersion()
*                   {
*                   	return CPluginAdapter::apiLevel;
*                   }
*                   
*                   VQMT_EXPORT int CompatibleWithVQMT(int vqmtVer)
*                   {
*                   	return vqmtVer >= CPluginAdapter::apiLevel ? 0 : -1;
*                   }
*			
*
*/
class ICustomPlugin
{
public:

	virtual ~ICustomPlugin() {};	//!< Destructor


	/**
	**************************************************************************
	* \brief Initialize metric plugin
	*
	*	Use this function to initialize metric parameters.
	*	It is always called before Measure(), MeasureAndVisualize(), GetAverage(), ResetMetricStat(),
	*	but other functions may be called earlier than Init().
	*	If metric supports configuration string, then GetConfigJSON() is called after Init().
	*
	* \param cc			[IN] - current color component, selected by user.
	* \param width		[IN] - width of images that will be measured.
	* \param height		[IN] - height of images that will be measured.
	* \param start_id	[IN] - identifier for metric values. VQMT will receive ids start_id, start_id+1, ..., start_id+N-1, where N
	*						   is number of values that are generated by this metric for one frame.
	*                          Metric should match these id(s) to produced values
	* \param valueSink	[IN] - metric can provide values not throw this object OR by return value of Measure[AndVisualize]
	*/
	virtual void Init(IMetricImage::ColorComponent cc, int width, int height, IMetricPlugin::ID start_id, IMetricValueSink* valueSink) = 0;

	/**
	**************************************************************************
	* \brief Measures metric on images
	*
	* \param images			[IN] - std::vector of images, as many as metric needs (it is returned by GetVideoNum(false)).
	* \return std::vector of pairs "id, value corresponding to the ID".
	*/
	virtual std::vector< std::pair <IMetricPlugin::ID, float> >	Measure(std::vector<IMetricImage*> &images) = 0;

	/**
	**************************************************************************
	* \brief Measures metric on images and saves visualization
	*
	* \param images			[IN] - std::vector of images, as many as metric needs (it is returned by GetVideoNum(true)).
	* \param vis			[IN, OUT] - pointer to RGB24 image, stored as BGRBGRBGRBGR...
	* \param vis_pitch		[IN] - row pitch of visualization image: distance in bytes between beginning of rows.
	* \return std::vector of pairs "id, value corresponding to the ID".
	*/
	virtual std::vector< std::pair <IMetricPlugin::ID, float> >	MeasureAndVisualize(std::vector<IMetricImage*>&images, unsigned char *vis, int vis_pitch) = 0;

	virtual void Stop() {}

	/**
	**************************************************************************
	* \brief Tells which ID correspond to which frame
	*	Tells which ID correspond to which frame, as given to Measure() and MeasureAndVisualize(),
	*	optionally can give name to an ID (default is empty name, L"").
	*	For instance, if it is metric with one ID without name and two frames, it should return ID, (0,1)
	*	and if it is with two IDs without names for two frames it should return ID1, (0), ID2, (1).
	*
	* \param visualize		[IN] - true if metric will be measured with visualization turned on.
	*						This parameter allows metric to have different amount of IDs when visualization
	*						is on or off.
	* \return std::vector of pairs <id, < std::vector of frame numbers corresponding to this id (for instance 0,1), name of ID>>.
	*/
	//virtual std::vector< std::pair <IMetricPlugin::ID, std::pair< std::vector <int>, std::wstring> > >	MapIDToFrame(bool visualize) = 0;
	virtual std::vector<IDinfo>	MapIDToFrame(bool visualize) = 0;

	/**
	**************************************************************************
	* \brief Returns average result
	*
	* \param visualize		[IN] - whether we ask for result of measurement with visualization.
	* \return std::vector of pairs "id, average value corresponding to the ID".
	*/
	virtual	std::vector< std::pair <IMetricPlugin::ID, float> > CalculateAverage(bool visualize) = 0;

	/**
	**************************************************************************
	* \brief Returns amount of video required for measurement (possibly with visualization)
	*
	* \param visualize		[IN] - if true, return amount of frames required for visualization.
	* \return amount of input frames.
	*/
	virtual int GetVideoNum(bool visualize) = 0;

	/**
	**************************************************************************
	* \brief Returns supported color components
	* \return std::vector of supported color components.
	*/
	virtual std::vector <IMetricImage::ColorComponent> GetSupportedColorcomponents() = 0;

	/**
	**************************************************************************
	* \brief Returns name of metric
	* \return name that will be written in name of resulting CSV file.
	*		  Usually in small letters without spaces, like "psnr" of "blurring_measure".
	*/
	virtual std::wstring				GetName() = 0;

	/**
	**************************************************************************
	* \brief Returns name of metric that will be used in interface
	* \return name that will be used in interface. Usually in big letters like 
	*		"PSNR" of "Blurring Measure".
	*/
	virtual std::wstring				GetInterfaceName() = 0;

	/**
	**************************************************************************
	* \brief Returns detailed name of metric
	* \return detailed name that will be used in interface. Example:
	*		"Peak signal-to-noise ratio".
	*/
	virtual std::wstring				GetLongName() = 0;

	/**
	**************************************************************************
	* \brief Returns units of metrics, for instance L"dB" or empty string L""
	* \return units of metrics, for instance L"dB" or empty string L"".
	*/
	virtual std::wstring				GetUnit() = 0;

	/**
	**************************************************************************
	* \return URL of information about metric.
	*/
	virtual std::wstring				GetMetrInfoURL() = 0;

	/**
	**************************************************************************
	* \brief Returns information about interpretation of metric values
	* \return true, if metric is the bigger the better. False if the smaller the better.
	*/
	virtual bool GetMetrIncline() = 0;

	/**
	**************************************************************************
	* \brief Returns configuration JSON
	* \return returns JSON object with keys - parameter names, values - objects with fields:
	* * "description" (string)
	* * "default_value" (string, integer or float)
	* * "possible_values" (optional; can be:
	*       + JSON-list of values for enum parameters
	*       + JSON-list of pairs for set of ranges)
	*/
	virtual const std::wstring& GetConfigJSON() {
		static const std::wstring obj = L"{}";
		return obj;
	}

	/**
	**************************************************************************
	* \brief Configures metric JSON. Should set JSON object with values to fields, specified in GetConfigJSON()
	* \return returns true if success and configuration correct
	*/
	virtual bool SetConfigParams(const std::wstring& json) { return false; }

	/**
	**************************************************************************
	* \brief Returns textual description of configuration
	* \return returns textual description of configuration
	*/
	virtual std::wstring GetConfigSummary() { return L""; }
};